<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-lang-key="title">آنالیز دانه‌بندی مصالح</title>
    <style>
        :root {
            --primary-bg-color: #2c3e50;
            --secondary-bg-color: #34495e;
            --header-bg-color: #1a252f;
            --text-color: #ecf0f1;
            --primary-accent-color: #e67e22;
            --secondary-accent-color: #f1c40f;
            --border-color: #4a627a;
            --input-bg-color: #2c3e50;
            --button-bg-color: #e67e22;
            --button-hover-bg-color: #d35400;
            --danger-color: #e74c3c;
        }
        body { font-family: 'Tahoma', sans-serif; background-color: var(--primary-bg-color); color: var(--text-color); margin: 0; padding: 20px; line-height: 1.6; }
        .container { max-width: 1200px; margin: 0 auto; background-color: var(--secondary-bg-color); padding: 20px; border-radius: 8px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); }
        header { background-color: var(--header-bg-color); padding: 20px; border-radius: 8px 8px 0 0; display: flex; justify-content: space-between; align-items: center; border-bottom: 3px solid var(--primary-accent-color); }
        header h1 { margin: 0; font-size: 2em; color: var(--secondary-accent-color); }
        .toolbar button { margin-left: 10px; }
        button { background-color: var(--button-bg-color); color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; font-size: 1em; transition: background-color 0.3s; }
        button:hover { background-color: var(--button-hover-bg-color); }
        #add-row { background-color: #27ae60; }
        #add-row:hover { background-color: #229954; }
        #calculate { background-color: var(--secondary-accent-color); color: #2c3e50; font-weight: bold; }
        #calculate:hover { background-color: #e0b60b; }
        button.delete-row { background-color: var(--danger-color); }
        button.delete-row:hover { background-color: #c0392b; }
        main { padding-top: 20px; }
        section { margin-bottom: 30px; background: var(--primary-bg-color); padding: 20px; border-radius: 8px; border: 1px solid var(--border-color); }
        h2 { color: var(--secondary-accent-color); border-bottom: 2px solid var(--border-color); padding-bottom: 10px; margin-top: 0; }
        select, input[type="number"] { width: 100%; padding: 10px; margin-top: 10px; margin-bottom: 10px; border-radius: 5px; border: 1px solid var(--border-color); background-color: var(--input-bg-color); color: var(--text-color); font-size: 1em; }
        .table-container { overflow-x: auto; -webkit-overflow-scrolling: touch; border: 1px solid var(--border-color); border-radius: 8px; margin-top: 20px; }
        #sieve-table { width: 100%; border-collapse: collapse; }
        #sieve-table th, #sieve-table td { border: 1px solid var(--border-color); padding: 12px; text-align: center; white-space: nowrap; }
        #sieve-table th { background-color: var(--header-bg-color); color: var(--secondary-accent-color); font-size: 1.1em; }
        #results-output p { font-size: 1.2em; background: var(--secondary-bg-color); padding: 10px; border-radius: 5px; border-left: 5px solid var(--primary-accent-color); }
        #results-output span { font-weight: bold; color: var(--secondary-accent-color); padding: 0 10px; }
        .chart-container { margin-top: 20px; padding: 15px; border: 1px solid var(--border-color); border-radius: 8px; background: var(--secondary-bg-color); }
        [dir="ltr"] body { text-align: left; }
        [dir="rtl"] body { text-align: right; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: var(--secondary-bg-color); padding: 30px; border-radius: 8px; width: 90%; max-width: 500px; border: 1px solid var(--border-color); box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .modal-content h3 { margin-top: 0; color: var(--secondary-accent-color); border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 20px; }
        .modal-content label { display: block; margin-top: 15px; margin-bottom: 5px; color: var(--text-color); }
        .modal-content input[type="text"], .modal-content textarea { width: 100%; padding: 10px; border-radius: 5px; border: 1px solid var(--border-color); background-color: var(--input-bg-color); color: var(--text-color); font-size: 1em; box-sizing: border-box; }
        .modal-actions { margin-top: 25px; display: flex; justify-content: flex-end; gap: 10px; }

        @media (max-width: 768px) {
            body { padding: 10px; }
            .container { padding: 10px; }
            header { flex-direction: column; align-items: flex-start; }
            header h1 { font-size: 1.5em; margin-bottom: 15px; }
            .toolbar { width: 100%; display: flex; justify-content: space-between; }
            .toolbar button { padding: 8px 10px; font-size: 0.9em; }
            #results-output {
                display: grid;
                grid-template-columns: 1fr;
                gap: 10px;
            }
            #charts {
                display: grid;
                grid-template-columns: 1fr;
                gap: 20px;
            }
            .chart-container { height: 300px; }
            h2 { font-size: 1.2em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 data-lang-key="header_title">آنالیز دانه‌بندی مصالح</h1>
            <div class="toolbar">
                <button id="lang-toggle" data-lang-key="lang_button">English</button>
                <button id="export-pdf" data-lang-key="export_pdf">خروجی PDF</button>
                <button id="export-excel" data-lang-key="export_excel">خروجی Excel</button>
            </div>
        </header>
        <main>
            <section id="material-selection">
                <h2 data-lang-key="material_selection_title">۱. انتخاب نوع مصالح</h2>
                <select id="material-type">
                    <option value="crushed-rock" data-lang-key="crushed_rock">سنگ شکن</option>
                    <option value="concrete-aggregates" data-lang-key="concrete_aggregates">بتن</option>
                    <option value="soil-clay" data-lang-key="soil_clay">رس</option>
                </select>
            </section>
             <section id="image-analysis-section" style="display: none;">
                <h2 data-lang-key="image_analysis_title">Image-Based Analysis for Crusher</h2>

                <div id="image-analysis-guide" style="background-color: var(--primary-bg-color); padding: 15px; border-radius: 5px; margin-bottom: 20px; border: 1px solid var(--border-color);">
                    <h3 data-lang-key="guide_title" style="margin-top: 0; color: var(--secondary-accent-color);">Image Capture Guide</h3>
                    <ul>
                        <li data-lang-key="guide_item1">Take the photo from a distance of ~1 meter, perpendicular to the surface.</li>
                        <li data-lang-key="guide_item2">Place a reference object with a known size (like a coin or bottle cap) next to the material.</li>
                        <li data-lang-key="guide_item3">Spread the material on a flat surface with a contrasting color (like a dark cloth or geomembrane).</li>
                        <li data-lang-key="guide_item4">For best accuracy, use "Manual" mode and draw a line across the reference object's diameter.</li>
                    </ul>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: end;">
                    <div>
                        <label for="image-upload" data-lang-key="image_upload_label">1. Upload Aggregate Image</label>
                        <input type="file" id="image-upload" accept="image/*" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid var(--border-color); background-color: var(--input-bg-color); color: var(--text-color);">
                        <button id="camera-btn" data-lang-key="camera_button" style="width: 100%; margin-top: 10px;">Use Camera</button>
                    </div>
                    <div>
                        <label for="reference-diameter" data-lang-key="reference_diameter_label">2. Real Diameter of Reference Object (mm)</label>
                        <input type="number" id="reference-diameter" placeholder="e.g., 24.26 for a US Quarter" value="24.26">
                    </div>
                </div>

                <div id="detection-mode-container" style="margin-top: 20px;">
                    <label for="detection-mode" data-lang-key="detection_mode_label" style="display: block; margin-bottom: 5px;">Reference Detection Mode:</label>
                    <select id="detection-mode" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid var(--border-color); background-color: var(--input-bg-color); color: var(--text-color); font-size: 1em;">
                        <option value="auto" data-lang-key="detection_mode_auto">Automatic (Circle Detection)</option>
                        <option value="manual" data-lang-key="detection_mode_manual">Manual (Draw Line)</option>
                    </select>
                </div>

                <div id="manual-selection-prompt" style="display: none; margin-top: 15px; padding: 10px; background-color: var(--primary-bg-color); border-radius: 5px; text-align: center; border: 1px dashed var(--secondary-accent-color);">
                    <p data-lang-key="manual_prompt" style="margin: 0; color: var(--secondary-accent-color);">Click and drag on the image to draw a line across the diameter of the reference object.</p>
                </div>

                <button id="process-image-btn" data-lang-key="process_image_button" disabled style="margin-top: 20px; width: 100%; background-color: var(--primary-accent-color);">3. Process Image & Calculate Gradation</button>

                <div class="canvas-container" style="margin-top: 20px; border: 1px solid var(--border-color); padding: 5px; min-height: 100px; background-color: #000;">
                    <canvas id="image-canvas" style="width: 100%; height: auto; cursor: default;"></canvas>
                </div>
            </section>
            <section id="sieve-inputs">
                <h2 data-lang-key="sieve_inputs_title">۲. ورود اطلاعات سرندها</h2>
                <div class="table-container">
                    <table id="sieve-table">
                        <thead>
                            <tr>
                                <th data-lang-key="sieve_name">نام سرند</th>
                                <th data-lang-key="sieve_size">اندازه سرند (µm)</th>
                                <th data-lang-key="retained_weight">وزن باقی‌مانده (گرم)</th>
                                <th data-lang-key="actions">عملیات</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
                <button id="add-row" data-lang-key="add_sieve">افزودن سرند</button>
                <button id="calculate" data-lang-key="calculate_button">محاسبه</button>
            </section>
            <section id="results" style="display: none;">
                <h2 data-lang-key="results_title">۳. نتایج آنالیز</h2>
                <div id="results-output">
                    <p><strong>D10:</strong> <span id="d10-value">-</span></p>
                    <p><strong>D30:</strong> <span id="d30-value">-</span></p>
                    <p><strong>D50 (Median):</strong> <span id="d50-value">-</span></p>
                    <p><strong>D60:</strong> <span id="d60-value">-</span></p>
                    <p><strong>D80:</strong> <span id="d80-value">-</span></p>
                    <p><strong data-lang-key="cu">ضریب یکنواختی (Cu):</strong> <span id="cu-value">-</span></p>
                    <p><strong data-lang-key="cc">ضریب انحنا (Cc):</strong> <span id="cc-value">-</span></p>
                    <p><strong data-lang-key="mean">میانگین وزنی (μm):</strong> <span id="mean-value">-</span></p>
                    <p><strong data-lang-key="std_dev">انحراف معیار:</strong> <span id="std-dev-value">-</span></p>
                    <div id="crusher-results" style="display: none;">
                        <p><strong data-lang-key="retained_75mm">درصد بزرگتر از ۷۵ میلی متر:</strong> <span id="retained-75mm-value">-</span></p>
                        <p><strong data-lang-key="retained_45mm">درصد بزرگتر از ۴۵ میلی متر:</strong> <span id="retained-45mm-value">-</span></p>
                    </div>
                </div>
                <div id="text-analysis-container" style="margin-top: 20px;">
                    <h3 data-lang-key="analysis_title">تحلیل متنی</h3>
                    <p id="text-analysis-output">-</p>
                </div>
            </section>
            <section id="charts" style="display: none;">
                <h2 data-lang-key="charts_title">۴. نمودارها</h2>
                <div class="chart-container" style="height: 400px; margin-bottom: 20px;"><canvas id="passing-curve-chart"></canvas></div>
                <div class="chart-container" style="height: 400px; margin-bottom: 20px;"><canvas id="retained-curve-chart"></canvas></div>
                <div class="chart-container" style="height: 400px;"><canvas id="histogram-chart"></canvas></div>
            </section>
        </main>
    </div>
    <div id="pdf-export-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3 data-lang-key="pdf_modal_title">اطلاعات گزارش PDF</h3>
            <div>
                <label for="report-title" data-lang-key="pdf_modal_report_title">عنوان گزارش</label>
                <input type="text" id="report-title" placeholder="مثال: نتایج آنالیز سرندی سنگ شکن شماره ۲">
            </div>
            <div>
                <label for="report-desc" data-lang-key="pdf_modal_report_desc">توضیحات</label>
                <textarea id="report-desc" rows="4" placeholder="مثال: نمونه مربوط به ده روز دوم خرداد ماه ۱۴۰۲ می‌باشد."></textarea>
            </div>
            <div>
                <label for="report-date" data-lang-key="pdf_modal_report_date">تاریخ</label>
                <input type="text" id="report-date">
            </div>
            <div class="modal-actions">
                <button id="cancel-pdf-export" data-lang-key="pdf_modal_cancel">انصراف</button>
                <button id="confirm-pdf-export" data-lang-key="pdf_modal_confirm">تولید گزارش</button>
            </div>
        </div>
    </div>

    <div id="camera-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3 data-lang-key="camera_modal_title">Capture Image</h3>
            <video id="camera-view" autoplay playsinline style="width: 100%; border-radius: 5px;"></video>
            <div class="modal-actions">
                <button id="cancel-camera" data-lang-key="camera_modal_cancel">Cancel</button>
                <button id="capture-btn" data-lang-key="camera_modal_capture">Capture</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.4.0/exceljs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/1.4.0/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <script async src="https://docs.opencv.org/4.9.0/opencv.js" onload="onOpenCvReady();"></script>
    <script>
        let cvIsReady = false;
        function onOpenCvReady() {
            cv = window.cv;
            cvIsReady = true;
            console.log("OpenCV.js is ready.");
            document.getElementById('process-image-btn').disabled = false;
        }

        let VAZIRMATN_FONT_BASE64 = "";

        async function loadFontAsBase64(fontUrl) {
            try {
                const response = await fetch(fontUrl);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const blob = await response.blob();
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (e) {
                console.error("Error loading font:", e);
                return null;
            }
        }
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', async function () {
            VAZIRMATN_FONT_BASE64 = await loadFontAsBase64('Vazirmatn-Regular.ttf');

            let passingChart, retainedChart, histogramChart;
            let lastCalculationData = null;

            const exportPdfBtn = document.getElementById('export-pdf');
            const exportExcelBtn = document.getElementById('export-excel');
            const langToggleBtn = document.getElementById('lang-toggle');
            const pdfModal = document.getElementById('pdf-export-modal');
            const cancelPdfExportBtn = document.getElementById('cancel-pdf-export');
            const confirmPdfExportBtn = document.getElementById('confirm-pdf-export');
            const reportDateInput = document.getElementById('report-date');

            exportPdfBtn.addEventListener('click', showPdfModal);
            cancelPdfExportBtn.addEventListener('click', () => pdfModal.style.display = 'none');
            confirmPdfExportBtn.addEventListener('click', exportToPdf);
            exportExcelBtn.addEventListener('click', exportToExcel);
            langToggleBtn.addEventListener('click', toggleLanguage);

            Chart.defaults.color = 'rgba(236, 240, 241, 0.8)';
            Chart.defaults.borderColor = 'rgba(74, 98, 122, 0.5)';
            Chart.defaults.plugins.legend.labels.boxWidth = 20;
            Chart.defaults.plugins.legend.labels.padding = 20;

            const PREDEFINED_SIEVES = {
                "crushed-rock": [
                    { label: '6 inch', size: 152400 }, { label: '4 inch', size: 101600 },
                    { label: '3 inch', size: 75000 }, { label: '2 inch', size: 50800 },
                    { label: '1.5 inch', size: 37500 }, { label: '1 inch', size: 25400 },
                    { label: '3/4 inch', size: 19000 }, { label: '1/2 inch', size: 12700 },
                    { label: '3/8 inch', size: 9525 }, { label: 'No. 4', size: 4750 },
                    { label: 'No. 10', size: 2000 }, { label: 'No. 40', size: 425 },
                    { label: 'No. 200', size: 75 }
                ],
                "concrete-aggregates": [
                    { label: '1.5 inch', size: 37500 }, { label: '1 inch', size: 25000 },
                    { label: '3/4 inch', size: 19000 }, { label: '1/2 inch', size: 12500 },
                    { label: '3/8 inch', size: 9500 }, { label: 'No. 4', size: 4750 },
                    { label: 'No. 8', size: 2360 }, { label: 'No. 16', size: 1180 },
                    { label: 'No. 30', size: 600 }, { label: 'No. 50', size: 300 },
                    { label: 'No. 100', size: 150 }, { label: 'No. 200', size: 75 }
                ],
                "soil-clay": [
                    { label: 'No. 10', size: 2000 }, { label: 'No. 20', size: 850 },
                    { label: 'No. 40', size: 425 }, { label: 'No. 60', size: 250 },
                    { label: 'No. 80', size: 180 }, { label: 'No. 100', size: 150 },
                    { label: 'No. 140', size: 106 }, { label: 'No. 200', size: 75 }
                ]
            };

            const addRowBtn = document.getElementById('add-row');
            const calculateBtn = document.getElementById('calculate');
            const sieveTableBody = document.querySelector('#sieve-table tbody');
            const materialTypeSelect = document.getElementById('material-type');

            function addSieveRow(sieve = { label: '', size: '', weight: '' }) {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><input type="text" class="sieve-label" value="${sieve.label}" placeholder="e.g., No. 4"></td>
                    <td><input type="number" class="sieve-size" value="${sieve.size}" placeholder="e.g., 4750"></td>
                    <td><input type="number" class="retained-weight" value="${sieve.weight}" placeholder="e.g., 500"></td>
                    <td><button class="delete-row" data-lang-key="delete_button">حذف</button></td>
                `;
                sieveTableBody.appendChild(row);
                row.querySelector('.delete-row').addEventListener('click', () => row.remove());
            }

            function loadSievesForMaterial() {
                sieveTableBody.innerHTML = '';
                const selectedMaterial = materialTypeSelect.value;
                const sieves = PREDEFINED_SIEVES[selectedMaterial];
                if (sieves) {
                    sieves.forEach(sieve => addSieveRow(sieve));
                }
                // Add Pan row
                const panRow = document.createElement('tr');
                panRow.innerHTML = `
                    <td><input type="text" class="sieve-label" value="Pan" readonly></td>
                    <td><input type="text" class="sieve-size" value="Pan" readonly></td>
                    <td><input type="number" class="retained-weight" placeholder="Weight on Pan"></td>
                    <td></td>
                `;
                sieveTableBody.appendChild(panRow);

                // Show/hide image analysis section
                const imageAnalysisSection = document.getElementById('image-analysis-section');
                if (selectedMaterial === 'crushed-rock') {
                    imageAnalysisSection.style.display = 'block';
                } else {
                    imageAnalysisSection.style.display = 'none';
                }
            }

            addRowBtn.addEventListener('click', () => addSieveRow());
            materialTypeSelect.addEventListener('change', loadSievesForMaterial);
            calculateBtn.addEventListener('click', performCalculations);

            const imageUpload = document.getElementById('image-upload');
            const imageCanvas = document.getElementById('image-canvas');
            const processImageBtn = document.getElementById('process-image-btn');
            const cameraBtn = document.getElementById('camera-btn');
            const cameraModal = document.getElementById('camera-modal');
            const cameraView = document.getElementById('camera-view');
            const cancelCameraBtn = document.getElementById('cancel-camera');
            const captureBtn = document.getElementById('capture-btn');
            const referenceDiameterInput = document.getElementById('reference-diameter');
            const detectionModeSelect = document.getElementById('detection-mode');
            const manualSelectionPrompt = document.getElementById('manual-selection-prompt');
            const ctx = imageCanvas.getContext('2d');
            let loadedImage = null;
            let pixelsPerMm = 0;
            let isDrawing = false;
            let manualLine = { start: null, end: null };

            imageUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    loadedImage = new Image();
                    loadedImage.onload = () => {
                        // Resize canvas to match image, but scale down for display if too large
                        const MAX_WIDTH = 800;
                        const scale = MAX_WIDTH / loadedImage.width;
                        imageCanvas.width = loadedImage.width;
                        imageCanvas.height = loadedImage.height;
                        imageCanvas.style.width = `${loadedImage.width * scale}px`;
                        imageCanvas.style.height = `${loadedImage.height * scale}px`;
                        ctx.drawImage(loadedImage, 0, 0);
                        manualLine = { start: null, end: null }; // Reset line on new image
                    };
                    loadedImage.src = event.target.result;
                };
                reader.readAsDataURL(file);
            });

            function getMousePos(canvas, evt) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                return {
                    x: (evt.clientX - rect.left) * scaleX,
                    y: (evt.clientY - rect.top) * scaleY
                };
            }

            imageCanvas.addEventListener('mousedown', (e) => {
                if (detectionModeSelect.value !== 'manual' || !loadedImage) return;
                isDrawing = true;
                manualLine.start = getMousePos(imageCanvas, e);
                manualLine.end = null;
            });

            imageCanvas.addEventListener('mousemove', (e) => {
                if (!isDrawing || !manualLine.start) return;
                const currentPos = getMousePos(imageCanvas, e);
                ctx.drawImage(loadedImage, 0, 0, imageCanvas.width, imageCanvas.height);
                ctx.beginPath();
                ctx.moveTo(manualLine.start.x, manualLine.start.y);
                ctx.lineTo(currentPos.x, currentPos.y);
                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 3;
                ctx.stroke();
            });

            imageCanvas.addEventListener('mouseup', (e) => {
                if (!isDrawing) return;
                isDrawing = false;
                manualLine.end = getMousePos(imageCanvas, e);
            });

            let cvWorker = new Worker('cv-worker.js');

            cvWorker.onmessage = function(e) {
                processImageBtn.disabled = false;
                processImageBtn.textContent = "Process Image & Calculate Gradation";

                if (e.data.error) {
                    alert(`Worker Error: ${e.data.error}`);
                    return;
                }

                if (e.data.success) {
                    const { particles, finalImageData } = e.data;

                    // The worker now sends the final image, so we just draw it.
                    if (finalImageData) {
                        ctx.putImageData(finalImageData, 0, 0);
                    }

                    populateSieveInputsFromParticles(particles);
                }
            };

            detectionModeSelect.addEventListener('change', () => {
                const mode = detectionModeSelect.value;
                if (mode === 'manual') {
                    manualSelectionPrompt.style.display = 'block';
                    imageCanvas.style.cursor = 'crosshair';
                } else {
                    manualSelectionPrompt.style.display = 'none';
                    imageCanvas.style.cursor = 'default';
                }
            });

            processImageBtn.addEventListener('click', () => {
                if (!cvIsReady || !loadedImage) {
                    alert("OpenCV is not ready or no image is loaded.");
                    return;
                }
                const realDiameter = parseFloat(referenceDiameterInput.value);
                if (isNaN(realDiameter) || realDiameter <= 0) {
                    alert("Please enter a valid diameter for the reference object.");
                    return;
                }

                const mode = detectionModeSelect.value;
                let workerData = {
                    imageData: ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height),
                    refDiameter: realDiameter,
                    mode: mode
                };

                if (mode === 'manual') {
                    if (!manualLine.start || !manualLine.end) {
                        alert("Please draw a line on the reference object first.");
                        return;
                    }
                    const dx = manualLine.end.x - manualLine.start.x;
                    const dy = manualLine.end.y - manualLine.start.y;
                    workerData.refPixelLength = Math.sqrt(dx * dx + dy * dy);
                    workerData.manualLine = manualLine;
                }

                processImageBtn.disabled = true;
                processImageBtn.textContent = "Processing...";

                // Post data to the worker
                cvWorker.postMessage(workerData);
            });

            let stream = null;

            async function openCamera() {
                try {
                    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                    cameraView.srcObject = stream;
                    cameraModal.style.display = 'flex';
                } catch (err) {
                    console.error("Error accessing camera:", err);
                    alert("Could not access camera. Please ensure permissions are granted and you are using a secure (HTTPS) connection.");
                }
            }

            function stopCameraStream() {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                cameraModal.style.display = 'none';
            }

            cameraBtn.addEventListener('click', openCamera);
            cancelCameraBtn.addEventListener('click', stopCameraStream);

            captureBtn.addEventListener('click', () => {
                const videoWidth = cameraView.videoWidth;
                const videoHeight = cameraView.videoHeight;
                imageCanvas.width = videoWidth;
                imageCanvas.height = videoHeight;
                ctx.drawImage(cameraView, 0, 0, videoWidth, videoHeight);

                loadedImage = new Image();
                loadedImage.src = imageCanvas.toDataURL('image/jpeg');

                stopCameraStream();
            });

            function populateSieveInputsFromParticles(particles) {
                const sieveRows = document.querySelectorAll('#sieve-table tbody tr');
                let sieves = [];

                sieveRows.forEach(row => {
                    const weightInput = row.querySelector('.retained-weight');
                    if (weightInput) weightInput.value = 0;
                    const sizeInput = row.querySelector('.sieve-size');
                    const sizeValue = parseFloat(sizeInput.value);
                    if (sizeInput && !isNaN(sizeValue)) {
                        sieves.push({ size: sizeValue, weightInput: weightInput, retainedArea: 0 });
                    } else if (sizeInput.value.toLowerCase() === 'pan') {
                        sieves.push({ size: 0, weightInput: weightInput, retainedArea: 0 });
                    }
                });
                sieves.sort((a, b) => b.size - a.size);

                particles.forEach(particle => {
                    let retainedSieve = sieves.find(sieve => particle.diameter > sieve.size);
                    if (retainedSieve) {
                        retainedSieve.retainedArea += particle.area;
                    }
                });

                const totalArea = sieves.reduce((sum, s) => sum + s.retainedArea, 0);
                const scaleFactor = totalArea > 0 ? 1000 / totalArea : 0;

                sieves.forEach(sieve => {
                    if (sieve.weightInput) {
                        const normalizedWeight = sieve.retainedArea * scaleFactor;
                        sieve.weightInput.value = normalizedWeight.toFixed(2);
                    }
                });

                alert(`${particles.length} particles detected. Sieve inputs populated. Automatically running analysis...`);

                // Automatically trigger the main calculation
                calculateBtn.click();
            }

            loadSievesForMaterial();

            function performCalculations() {
                let sieves = [];
                sieveTableBody.querySelectorAll('tr').forEach(row => {
                    const sizeInput = row.querySelector('.sieve-size');
                    const weightInput = row.querySelector('.retained-weight');
                    const isPan = sizeInput.value.toLowerCase() === 'pan';
                    const size = isPan ? 0 : parseFloat(sizeInput.value);
                    const weight = parseFloat(weightInput.value) || 0;
                    if (!isNaN(size) && weight >= 0) sieves.push({ size, weight, isPan });
                });

                sieves.sort((a, b) => b.size - a.size);
                const totalWeight = sieves.reduce((sum, s) => sum + s.weight, 0);
                if (totalWeight === 0) {
                    alert(translations[currentLang]['alert_no_weight']);
                    return;
                }

                let cumulativeRetained = 0;
                let passingData = [];
                sieves.forEach(sieve => {
                    cumulativeRetained += sieve.weight;
                    sieve.cumulativeRetainedPercent = (cumulativeRetained / totalWeight) * 100;
                    sieve.passingPercent = 100 - sieve.cumulativeRetainedPercent;
                    if (!sieve.isPan) passingData.push({ size: sieve.size, passing: sieve.passingPercent });
                });

                const firstSieveSize = passingData.length > 0 ? passingData[0].size : 0;
                passingData.unshift({ size: firstSieveSize * 2, passing: 100 });

                const d10 = getDiameterForPassing(10, passingData);
                const d30 = getDiameterForPassing(30, passingData);
                const d50 = getDiameterForPassing(50, passingData);
                const d60 = getDiameterForPassing(60, passingData);
                const d80 = getDiameterForPassing(80, passingData);

                document.getElementById('d10-value').textContent = d10.toFixed(3);
                document.getElementById('d30-value').textContent = d30.toFixed(3);
                document.getElementById('d50-value').textContent = d50.toFixed(3);
                document.getElementById('d60-value').textContent = d60.toFixed(3);
                document.getElementById('d80-value').textContent = d80.toFixed(3);

                const cu = (d10 > 0) ? (d60 / d10) : 0;
                const cc = (d10 > 0 && d60 > 0) ? ((d30 * d30) / (d10 * d60)) : 0;
                document.getElementById('cu-value').textContent = cu ? cu.toFixed(2) : 'N/A';
                document.getElementById('cc-value').textContent = cc ? cc.toFixed(2) : 'N/A';

                let weightedMeanSum = 0;
                let particleData = [];
                const nonPanSieves = sieves.filter(s => !s.isPan);
                for (let i = 0; i < nonPanSieves.length; i++) {
                    const upperSize = (i === 0) ? nonPanSieves[i].size * 2 : nonPanSieves[i - 1].size;
                    const meanSize = Math.sqrt(upperSize * nonPanSieves[i].size);
                    if (nonPanSieves[i].weight > 0) {
                        particleData.push({ meanSize, weight: nonPanSieves[i].weight });
                        weightedMeanSum += meanSize * nonPanSieves[i].weight;
                    }
                }
                const panWeight = sieves.find(s => s.isPan)?.weight || 0;
                if (panWeight > 0 && nonPanSieves.length > 0) {
                    const meanSize = nonPanSieves[nonPanSieves.length - 1].size / 2;
                    particleData.push({ meanSize, weight: panWeight });
                    weightedMeanSum += meanSize * panWeight;
                }
                const weightedMean = totalWeight > 0 ? weightedMeanSum / totalWeight : 0;
                let varianceSum = 0;
                if (totalWeight > 0) particleData.forEach(p => varianceSum += Math.pow(p.meanSize - weightedMean, 2) * p.weight);
                const standardDeviation = Math.sqrt(totalWeight > 0 ? varianceSum / totalWeight : 0);

                document.getElementById('mean-value').textContent = weightedMean.toFixed(3);
                document.getElementById('std-dev-value').textContent = standardDeviation.toFixed(2);

                let passing75mm, passing45mm;

                const sieve75mm = sieves.find(s => s.size === 75000);
                if (sieve75mm) {
                    passing75mm = sieve75mm.passingPercent;
                } else {
                    passing75mm = getPassingForDiameter(75000, passingData) ?? 0;
                }

                const sieve45mm = sieves.find(s => s.size === 45000);
                if (sieve45mm) {
                    passing45mm = sieve45mm.passingPercent;
                } else {
                    passing45mm = getPassingForDiameter(45000, passingData) ?? 0;
                }

                const retained75mm = 100 - passing75mm;
                const retained45mm = 100 - passing45mm;

                document.getElementById('retained-75mm-value').textContent = retained75mm.toFixed(2) + ' %';
                document.getElementById('retained-45mm-value').textContent = retained45mm.toFixed(2) + ' %';

                const materialType = document.getElementById('material-type').value;
                const crusherResultsEl = document.getElementById('crusher-results');
                if (materialType === 'crushed-rock') {
                    crusherResultsEl.style.display = 'block';
                } else {
                    crusherResultsEl.style.display = 'none';
                }
                const fmSieveSizes = [9500, 4750, 2360, 1180, 600, 300, 150]; // Standard sieves for FM
                const cumulativeRetainedOnFMSieves = sieves
                    .filter(s => fmSieveSizes.includes(s.size))
                    .reduce((sum, s) => sum + s.cumulativeRetainedPercent, 0);
                const finenessModulus = cumulativeRetainedOnFMSieves > 0 ? cumulativeRetainedOnFMSieves / 100 : 0;

                const dValues = { d10, d30, d50, d60, d80 };
                const coeffs = { cu, cc };
                const stats = { mean: weightedMean, stdDev: standardDeviation, retained75mm, retained45mm, fm: finenessModulus };

                const analysisKeys = generateTextAnalysis(coeffs, dValues, stats, materialType, passingData);
                const analysisText = analysisKeys.map(key => {
                    if (typeof key === 'object') {
                        return (translations[currentLang][key.key] || key.key).replace('{value}', key.value);
                    }
                    return translations[currentLang][key] || key;
                }).join(' ');
                document.getElementById('text-analysis-output').textContent = analysisText;

                lastCalculationData = {
                    sieves, dValues, coeffs, analysisKeys, analysisText, stats, passingData
                };

                document.getElementById('results').style.display = 'block';
                document.getElementById('charts').style.display = 'block';
                updateCharts();
            }

            function generateTextAnalysis(coeffs, dValues, stats, materialType, passingData) {
                const { cu, cc } = coeffs;
                const { fm } = stats;
                const { d80 } = dValues;
                const keys = [];

                const passing75micron = getPassingForDiameter(75, passingData);
                if (passing75micron === null) return ['analysis_err_no_fines'];

                const passing4750micron = getPassingForDiameter(4750, passingData);
                if (passing4750micron === null) return ['analysis_err_no_split'];

                const finesPercent = passing75micron;
                const gravelPercent = 100 - passing4750micron;
                const sandPercent = 100 - finesPercent - gravelPercent;

                keys.push('analysis_title_uscs');
                if (finesPercent > 50) {
                    keys.push('analysis_fine_grained');
                } else {
                    keys.push({key: 'analysis_coarse_grained', value: (100-finesPercent).toFixed(1)});
                    const coarseFractionIsGravel = gravelPercent > sandPercent;

                    if (coarseFractionIsGravel) {
                        keys.push({key: 'analysis_base_gravel', value: gravelPercent.toFixed(1)});
                        if (finesPercent < 5) {
                            keys.push('analysis_fines_lt_5');
                            if (cu >= 4 && cc >= 1 && cc <= 3) keys.push('analysis_gw'); else keys.push('analysis_gp');
                        } else if (finesPercent > 12) {
                            keys.push('analysis_fines_gt_12', 'analysis_plasticity_gm_gc');
                        } else {
                            keys.push('analysis_fines_borderline', 'analysis_dual_symbol_gravel');
                        }
                    } else {
                        keys.push({key: 'analysis_base_sand', value: sandPercent.toFixed(1)});
                        if (finesPercent < 5) {
                            keys.push('analysis_fines_lt_5');
                            if (cu >= 6 && cc >= 1 && cc <= 3) keys.push('analysis_sw'); else keys.push('analysis_sp');
                        } else if (finesPercent > 12) {
                            keys.push('analysis_fines_gt_12', 'analysis_plasticity_sm_sc');
                        } else {
                            keys.push('analysis_fines_borderline', 'analysis_dual_symbol_sand');
                        }
                    }
                    if (cu && cc) {
                        keys.push({key: 'analysis_cu_value', value: cu.toFixed(2)});
                        keys.push({key: 'analysis_cc_value', value: cc.toFixed(2)});
                    }
                }

                // Specific analysis based on material type
                if (materialType === 'concrete-aggregates') {
                    keys.push('analysis_title_concrete');
                    if (fm && fm > 0) {
                        keys.push({key: 'analysis_fm_value', value: fm.toFixed(2)});
                        if (fm >= 2.3 && fm <= 3.1) keys.push('analysis_fm_good');
                        else if (fm < 2.3) keys.push('analysis_fm_fine');
                        else keys.push('analysis_fm_coarse');
                    } else {
                        keys.push('analysis_fm_na');
                    }
                } else if (materialType === 'crushed-rock') {
                    keys.push('analysis_title_heap_leach');
                    if (finesPercent < 15) {
                        keys.push({key: 'analysis_heap_leach_fines_ok', value: finesPercent.toFixed(1)});
                    } else {
                        keys.push({key: 'analysis_heap_leach_fines_high', value: finesPercent.toFixed(1)});
                    }
                    if (d80) {
                        const d80_mm = d80 / 1000;
                        keys.push({key: 'analysis_heap_leach_d80', value: d80_mm.toFixed(1)});
                        if (d80_mm > 20) keys.push('analysis_heap_leach_d80_coarse');
                        else if (d80_mm < 5) keys.push('analysis_heap_leach_d80_fine');
                    }
                }

                return keys;
            }

            async function exportToExcel() {
                if (!lastCalculationData) {
                    alert(translations[currentLang]['alert_no_calculation']);
                    return;
                }

                const originalButtonText = exportExcelBtn.textContent;
                exportExcelBtn.textContent = translations[currentLang]['generating'];
                exportExcelBtn.disabled = true;

                try {
                    const workbook = new ExcelJS.Workbook();
                    workbook.creator = 'Sieve Analysis App';
                    workbook.created = new Date();

                    // --- 1. Summary Sheet ---
                    const summarySheet = workbook.addWorksheet('Summary');
                    const { sieves, dValues, coeffs, stats, analysisText } = lastCalculationData;
                    const isFa = currentLang === 'fa';

                    // Title
                    summarySheet.mergeCells('A1:E1');
                    summarySheet.getCell('A1').value = translations[currentLang]['title'];
                    summarySheet.getCell('A1').font = { size: 16, bold: true };
                    summarySheet.getCell('A1').alignment = { horizontal: 'center' };

                    // Summary Data
                    const summaryData = [
                        ['D10', dValues.d10], ['D30', dValues.d30], ['D50', dValues.d50],
                        ['D60', dValues.d60], ['D80', dValues.d80],
                        [translations[currentLang]['cu'], coeffs.cu],
                        [translations[currentLang]['cc'], coeffs.cc],
                        [translations[currentLang]['mean'], stats.mean],
                        [translations[currentLang]['std_dev'], stats.stdDev],
                        [translations[currentLang]['retained_75mm'], stats.retained75mm],
                        [translations[currentLang]['retained_45mm'], stats.retained45mm]
                    ];

                    let currentRow = 3;
                    summaryData.forEach(([label, value]) => {
                        if (value !== null && typeof value !== 'undefined') {
                            const row = summarySheet.addRow([label, parseFloat(value.toFixed(3))]);
                            row.getCell(1).font = { bold: true };
                        }
                    });

                    summarySheet.getColumn('A').width = 30;
                    summarySheet.getColumn('B').width = 15;

                    // Text Analysis
                    const analysisRow = summarySheet.addRow([]); // Spacer
                    const analysisHeaderRow = summarySheet.addRow([translations[currentLang]['analysis_title']]);
                    analysisHeaderRow.getCell(1).font = { bold: true, size: 14 };
                    const analysisContentRow = summarySheet.addRow([analysisText]);
                    analysisContentRow.getCell(1).alignment = { wrapText: true };


                    // --- 2. Chart Images ---
                    const charts = [
                        { id: 'passing-curve-chart', col: 'D' },
                        { id: 'retained-curve-chart', col: 'D' },
                        { id: 'histogram-chart', col: 'D' }
                    ];
                    let chartY = 2; // Start charts in row 2
                    for (const chart of charts) {
                        const canvas = await html2canvas(document.getElementById(chart.id));
                        const imageBase64 = canvas.toDataURL('image/png');
                        const imageId = workbook.addImage({
                            base64: imageBase64,
                            extension: 'png',
                        });
                        summarySheet.addImage(imageId, `${chart.col}${chartY}:${chart.col === 'D' ? 'K' : 'S'}${chartY + 15}`);
                        chartY += 17;
                    }

                    // --- 3. Raw Data Sheet ---
                    const dataSheet = workbook.addWorksheet('Raw Data');
                    dataSheet.columns = [
                        { header: translations[currentLang]['sieve_size'], key: 'size', width: 20 },
                        { header: translations[currentLang]['retained_weight'], key: 'weight', width: 25, style: { numFmt: '0.00' } },
                        { header: 'Cumulative Retained (%)', key: 'cumRetained', width: 25, style: { numFmt: '0.00' } },
                        { header: 'Cumulative Passing (%)', key: 'cumPassing', width: 25, style: { numFmt: '0.00' } },
                    ];

                    const tableBody = sieves.map(s => ({
                        size: s.isPan ? translations[currentLang]['pan'] : s.size,
                        weight: s.weight,
                        cumRetained: s.cumulativeRetainedPercent,
                        cumPassing: s.passingPercent,
                    }));
                    dataSheet.addRows(tableBody);

                    // --- 4. Generate File ---
                    const buffer = await workbook.xlsx.writeBuffer();
                    saveAs(new Blob([buffer]), 'Gradation_Analysis_Report.xlsx');

                } catch (e) {
                    console.error("Error generating Excel:", e);
                } finally {
                    exportExcelBtn.textContent = originalButtonText;
                    exportExcelBtn.disabled = false;
                }
            }

            function showPdfModal() {
                if (!lastCalculationData) {
                    alert(translations[currentLang]['alert_no_calculation']);
                    return;
                }
                reportDateInput.value = new Date().toLocaleDateString(currentLang === 'fa' ? 'fa-IR' : 'en-US');
                pdfModal.style.display = 'flex';
            }

            async function exportToPdf() {
                if (!lastCalculationData) {
                    alert(translations[currentLang]['alert_no_calculation']);
                    return;
                }
                if (!VAZIRMATN_FONT_BASE64) {
                    alert("Font file has not been loaded yet. Please wait a moment and try again.");
                    return;
                }

                const { jsPDF } = window.jspdf;
                const isFa = currentLang === 'fa';

                const originalButtonText = confirmPdfExportBtn.textContent;
                confirmPdfExportBtn.textContent = translations[currentLang]['generating'];
                confirmPdfExportBtn.disabled = true;

                try {
                    const doc = new jsPDF();

                    // --- 1. Add Font for Persian support ---
                    doc.addFileToVFS("Vazirmatn-Regular.ttf", VAZIRMATN_FONT_BASE64);
                    doc.addFont("Vazirmatn-Regular.ttf", "Vazirmatn", "normal");
                    doc.setFont("Vazirmatn");

                    // --- 2. Get Custom User Input & Data ---
                    const reportTitle = document.getElementById('report-title').value || (isFa ? "گزارش تحلیل دانه‌بندی" : "Gradation Analysis Report");
                    const reportDesc = document.getElementById('report-desc').value;
                    const reportDate = document.getElementById('report-date').value;
                    const { sieves, dValues, coeffs, stats, analysisText } = lastCalculationData;

                    // --- 3. Generate Chart Images ---
                    const chartConfigs = [
                        { id: 'passing-curve-chart', title: translations[currentLang]['chart_title_passing'] },
                        { id: 'retained-curve-chart', title: translations[currentLang]['chart_title_retained'] },
                        { id: 'histogram-chart', title: translations[currentLang]['chart_title_histogram'] }
                    ];
                    const chartImages = [];
                    for (const config of chartConfigs) {
                        const canvas = await html2canvas(document.getElementById(config.id), { backgroundColor: '#34495e' });
                        chartImages.push(canvas.toDataURL('image/png'));
                    }

                    // --- 4. Build PDF Document ---
                    const pageWidth = doc.internal.pageSize.getWidth();
                    const pageMargin = 15;

                    doc.setFontSize(22);
                    doc.text(reportTitle, isFa ? pageWidth - pageMargin : pageWidth / 2, 20, { align: isFa ? 'right' : 'center' });

                    doc.setFontSize(12);
                    doc.text(reportDate, isFa ? pageWidth - pageMargin : pageWidth / 2, 30, { align: isFa ? 'right' : 'center' });

                    let yPos = 40;
                    if (reportDesc) {
                        const descLines = doc.splitTextToSize(reportDesc, pageWidth - (pageMargin * 2));
                        doc.text(descLines, isFa ? pageWidth - pageMargin : pageMargin, yPos, { align: isFa ? 'right' : 'left' });
                        yPos += (descLines.length * 5) + 10;
                    } else {
                        yPos = 45;
                    }

                    // --- Summary Table ---
                    doc.setFontSize(16);
                    doc.text(translations[currentLang]['results_title'], isFa ? pageWidth - pageMargin : pageMargin, yPos, { align: isFa ? 'right' : 'left' });
                    yPos += 5;
                    const summaryHead = [['Parameter', 'Value']];
                    const summaryBody = [
                        ...Object.entries(dValues).map(([key, value]) => [key, value.toFixed(3)]),
                        ['Cu', coeffs.cu.toFixed(2)],
                        ['Cc', coeffs.cc.toFixed(2)],
                        ['Fineness Modulus', stats.fm.toFixed(2)],
                        ['Retained > 75mm (%)', stats.retained75mm.toFixed(2)],
                        ['Retained > 45mm (%)', stats.retained45mm.toFixed(2)],
                    ];

                    const summaryTableOptions = {
                        startY: yPos,
                        theme: 'grid',
                        headStyles: { fillColor: [44, 62, 80], font: 'Vazirmatn' },
                        styles: { font: 'Vazirmatn' }
                    };

                    if (isFa) {
                        summaryTableOptions.head = summaryHead.map(row => row.reverse());
                        summaryTableOptions.body = summaryBody.map(row => row.reverse());
                        summaryTableOptions.headStyles.halign = 'right';
                        summaryTableOptions.styles.halign = 'right';
                    } else {
                        summaryTableOptions.head = summaryHead;
                        summaryTableOptions.body = summaryBody;
                    }
                    doc.autoTable(summaryTableOptions);
                    yPos = doc.autoTable.previous.finalY + 15;

                    // --- Text Analysis ---
                    doc.setFontSize(16);
                    doc.text(translations[currentLang]['analysis_title'], isFa ? pageWidth - pageMargin : pageMargin, yPos, { align: isFa ? 'right' : 'left' });
                    yPos += 8;
                    doc.setFontSize(11);
                    const analysisLines = doc.splitTextToSize(analysisText, pageWidth - (pageMargin * 2));
                    doc.text(analysisLines, isFa ? pageWidth - pageMargin : pageMargin, yPos, { align: isFa ? 'right' : 'left' });
                    yPos += analysisLines.length * 5 + 10;

                    // --- Charts ---
                    doc.addPage();
                    doc.setFontSize(16);
                    doc.text(translations[currentLang]['charts_title'], 105, 15, { align: 'center' });
                    doc.addImage(chartImages[0], 'PNG', 15, 25, 180, 80);
                    doc.addImage(chartImages[1], 'PNG', 15, 115, 180, 80);
                    doc.addImage(chartImages[2], 'PNG', 15, 205, 180, 80);

                    // --- Raw Data Table ---
                    doc.addPage();
                    doc.setFontSize(16);
                    doc.text(translations[currentLang]['raw_data_title'] || "Raw Data", isFa ? pageWidth - pageMargin : pageWidth / 2, 15, { align: isFa ? 'right' : 'center' });
                    const rawDataHead = [[
                        translations[currentLang]['sieve_size'],
                        translations[currentLang]['retained_weight'],
                        'Cumulative Retained (%)',
                        'Passing (%)'
                    ]];
                    const rawDataBody = sieves.map(s => [
                        s.isPan ? translations[currentLang]['pan'] : s.size.toString(),
                        s.weight.toString(),
                        s.cumulativeRetainedPercent.toFixed(2),
                        s.passingPercent.toFixed(2)
                    ]);

                    const rawTableOptions = {
                        startY: 25,
                        theme: 'grid',
                        headStyles: { fillColor: [44, 62, 80], font: 'Vazirmatn' },
                        styles: { font: 'Vazirmatn' }
                    };

                    if (isFa) {
                        rawTableOptions.head = rawDataHead.map(row => row.reverse());
                        rawTableOptions.body = rawDataBody.map(row => row.reverse());
                        rawTableOptions.headStyles.halign = 'right';
                        rawTableOptions.styles.halign = 'right';
                    } else {
                        rawTableOptions.head = rawDataHead;
                        rawTableOptions.body = rawDataBody;
                    }
                    doc.autoTable(rawTableOptions);

                    // --- 5. Save Document ---
                    doc.save("Sieve_Analysis_Report.pdf");

                } catch (e) {
                    console.error("Error generating PDF:", e);
                    alert("An error occurred while generating the PDF.");
                } finally {
                    confirmPdfExportBtn.textContent = originalButtonText;
                    confirmPdfExportBtn.disabled = false;
                    pdfModal.style.display = 'none';
                }
            }

            function updateCharts() {
                if (!lastCalculationData) return;
                const { sieves, stats, dValues, passingData } = lastCalculationData;
                const { mean, stdDev, retained75mm, retained45mm } = stats;
                const { d80 } = dValues;

                const labels = sieves.filter(s => !s.isPan).map(s => s.size).reverse();
                const passingPercent = sieves.filter(s => !s.isPan).map(s => s.passingPercent).reverse();
                const cumulativeRetainedPercent = sieves.filter(s => !s.isPan).map(s => s.cumulativeRetainedPercent).reverse();
                const totalWeight = sieves.reduce((sum, s) => sum + s.weight, 0);
                const retainedPercent = sieves.filter(s => !s.isPan).map(s => (s.weight / totalWeight) * 100).reverse();

                if (passingChart) passingChart.destroy();
                if (retainedChart) retainedChart.destroy();
                if (histogramChart) histogramChart.destroy();

                const passingAnnotations = {
                    d80Line: { type: 'line', yMin: 80, yMax: 80, borderColor: 'rgba(231, 76, 60, 0.8)', borderWidth: 2, borderDash: [6, 6], label: { content: `D80 = ${d80.toFixed(1)} µm`, enabled: true, position: 'start', backgroundColor: 'rgba(231, 76, 60, 0.8)' } },
                    d80point: { type: 'point', xValue: d80, yValue: 80, radius: 5, backgroundColor: 'rgba(231, 76, 60, 1)' }
                };

                const passingOptions = { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: translations[currentLang]['chart_title_passing'], color: 'white', font: { size: 18 } }, legend: { position: 'top' }, annotation: { annotations: passingAnnotations } }, scales: { x: { type: 'logarithmic', reverse: false, title: { display: true, text: translations[currentLang]['chart_xaxis_label'], color: 'white' }, ticks: { color: 'white' } }, y: { beginAtZero: true, max: 100, title: { display: true, text: translations[currentLang]['chart_yaxis_passing'], color: 'white' }, ticks: { color: 'white' } } } };
                passingChart = new Chart(document.getElementById('passing-curve-chart'), { type: 'line', data: { labels: labels, datasets: [{ label: translations[currentLang]['chart_legend_passing'], data: passingPercent, borderColor: '#3498db', backgroundColor: 'rgba(52, 152, 219, 0.2)', fill: true, tension: 0.1 }] }, options: passingOptions });

                const retainedAnnotations = {};
                const materialType = document.getElementById('material-type').value;
                if (materialType === 'crushed-rock') {
                    if (retained75mm !== null) {
                        retainedAnnotations.line75k = { type: 'label', xValue: 75000, yValue: retained75mm, content: `${retained75mm.toFixed(1)}% @ 75mm`, backgroundColor: 'rgba(231, 76, 60, 0.8)', font: { size: 12 }, padding: 6, borderRadius: 6, yAdjust: -15 };
                    }
                    if (retained45mm !== null) {
                        retainedAnnotations.line45k = { type: 'label', xValue: 45000, yValue: retained45mm, content: `${retained45mm.toFixed(1)}% @ 45mm`, backgroundColor: 'rgba(231, 76, 60, 0.8)', font: { size: 12 }, padding: 6, borderRadius: 6, yAdjust: 15 };
                    }
                }

                const retainedOptions = { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: translations[currentLang]['chart_title_retained'], color: 'white', font: { size: 18 } }, legend: { position: 'top' }, annotation: { annotations: retainedAnnotations } }, scales: { x: { type: 'logarithmic', reverse: false, title: { display: true, text: translations[currentLang]['chart_xaxis_label'], color: 'white' }, ticks: { color: 'white' } }, y: { beginAtZero: true, max: 100, title: { display: true, text: translations[currentLang]['chart_yaxis_retained'], color: 'white' }, ticks: { color: 'white' } } } };
                retainedChart = new Chart(document.getElementById('retained-curve-chart'), { type: 'line', data: { labels: labels, datasets: [{ label: translations[currentLang]['chart_legend_retained'], data: cumulativeRetainedPercent, borderColor: '#e74c3c', backgroundColor: 'rgba(231, 76, 60, 0.2)', fill: true, tension: 0.1 }] }, options: retainedOptions });

                const histogramOptions = { responsive: true, maintainAspectRatio: false, plugins: { title: { display: true, text: translations[currentLang]['chart_title_histogram'], color: 'white', font: { size: 18 } }, legend: { display: false }, annotation: { annotations: { meanLine: { type: 'line', scaleID: 'x', value: mean, borderColor: '#e74c3c', borderWidth: 3, label: { content: `${translations[currentLang]['mean_label']}: ${mean.toFixed(0)} µm`, enabled: true, position: 'top', backgroundColor: 'rgba(231, 76, 60, 0.8)' } }, stdDevLabel: { type: 'label', xValue: mean, yValue: Math.max(...retainedPercent) * 0.9, backgroundColor: 'rgba(44, 62, 80, 0.7)', content: `${translations[currentLang]['std_dev_label']}: ${stdDev.toFixed(0)}`, font: { size: 12 }, padding: 6, borderRadius: 6 } } } }, scales: { x: { type: 'logarithmic', reverse: false, title: { display: true, text: translations[currentLang]['chart_xaxis_label'], color: 'white' }, ticks: { color: 'white' } }, y: { beginAtZero: true, title: { display: true, text: translations[currentLang]['chart_yaxis_retained_hist'], color: 'white' }, ticks: { color: 'white' } } } };
                histogramChart = new Chart(document.getElementById('histogram-chart'), { type: 'bar', data: { datasets: [{ label: translations[currentLang]['chart_legend_retained_hist'], data: labels.map((label, i) => ({ x: label, y: retainedPercent[i] })), backgroundColor: '#f1c40f', borderColor: '#f39c12', borderWidth: 1 }] }, options: histogramOptions });
            }

            function getDiameterForPassing(targetPassing, data) {
                let p1 = null, p2 = null;
                for (let i = 0; i < data.length - 1; i++) {
                    if (data[i].passing >= targetPassing && data[i + 1].passing <= targetPassing) {
                        p1 = data[i]; p2 = data[i + 1]; break;
                    }
                }
                if (!p1 || !p2 || p1.passing === p2.passing) {
                    if (targetPassing === 100 && data.length > 0) return data[0].size;
                    const lastPoint = data[data.length - 1];
                    if (targetPassing <= lastPoint.passing) return lastPoint.size;
                    return 0;
                }
                const logD = Math.log(p1.size) + (Math.log(p2.size) - Math.log(p1.size)) * (targetPassing - p1.passing) / (p2.passing - p1.passing);
                return Math.exp(logD);
            }

            function getPassingForDiameter(targetDiameter, data) {
                let p1 = null, p2 = null;
                for (let i = 0; i < data.length - 1; i++) {
                    if (data[i].size >= targetDiameter && data[i + 1].size <= targetDiameter) {
                        p1 = data[i]; p2 = data[i + 1]; break;
                    }
                }
                if (!p1 || !p2 || p1.size === p2.size) return null;
                const passing = p1.passing + (p2.passing - p1.passing) * (Math.log(targetDiameter) - Math.log(p1.size)) / (Math.log(p2.size) - Math.log(p1.size));
                return passing;
            }

            const translations = {
                en: {
                    title: "Gradation Analysis of Materials", header_title: "Gradation Analysis", lang_button: "فارسی", export_pdf: "Export PDF", export_excel: "Export Excel",
                    material_selection_title: "1. Select Material", crushed_rock: "Crushed Rock", concrete_aggregates: "Concrete Aggregates", soil_clay: "Soil/Clay",
                    image_analysis_title: "Image-Based Analysis for Crusher",
                    guide_title: "Image Capture Guide",
                    guide_item1: "Take the photo from a distance of ~1 meter, perpendicular to the surface.",
                    guide_item2: "Place a reference object with a known size (like a coin or bottle cap) next to the material.",
                    guide_item3: "Spread the material on a flat surface with a contrasting color (like a dark cloth or geomembrane).",
                    guide_item4: "For best accuracy, use 'Manual' mode and draw a line across the reference object's diameter.",
                    image_upload_label: "1. Upload Aggregate Image",
                    camera_button: "Use Camera",
                    reference_diameter_label: "2. Real Diameter of Reference Object (mm)",
                    detection_mode_label: "Reference Detection Mode:",
                    detection_mode_auto: "Automatic (Circle Detection)",
                    detection_mode_manual: "Manual (Draw Line)",
                    manual_prompt: "Click and drag on the image to draw a line across the diameter of the reference object.",
                    process_image_button: "3. Process Image & Calculate Gradation",
                    camera_modal_title: "Capture Image",
                    camera_modal_cancel: "Cancel",
                    camera_modal_capture: "Capture",
                    sieve_inputs_title: "2. Enter Sieve Data", sieve_name: "Sieve Name", sieve_size: "Sieve Size (µm)", retained_weight: "Retained Weight (g)",
                    actions: "Actions", add_sieve: "Add Sieve", delete_button: "Delete", calculate_button: "Calculate", results_title: "3. Analysis Results", cu: "Coefficient of Uniformity (Cu):",
                    cc: "Coefficient of Curvature (Cc):", mean: "Weighted Mean (µm):", std_dev: "Standard Deviation:", analysis_title: "Text Analysis", charts_title: "4. Charts",
                    retained_75mm: "Percent Greater than 75mm:", retained_45mm: "Percent Greater than 45mm:",
                    alert_no_weight: "Total weight cannot be zero. Please enter retained weights.", alert_no_calculation: "Please perform a calculation first.", generating: "Generating...",
                    pdf_modal_title: "PDF Report Information", pdf_modal_report_title: "Report Title", pdf_modal_report_desc: "Description", pdf_modal_report_date: "Date",
                    pdf_modal_cancel: "Cancel", pdf_modal_confirm: "Generate Report", pan: "Pan", raw_data_title: "Raw Data",
                    chart_title_passing: "Cumulative Passing Curve", chart_title_retained: "Cumulative Retained Curve", chart_title_histogram: "Histogram (Percent Retained)",
                    chart_xaxis_label: "Sieve Size (µm) - Log Scale", chart_yaxis_passing: "Passing (%)", chart_yaxis_retained: "Retained (%)", chart_yaxis_retained_hist: "Percent Retained (%)",
                    chart_legend_passing: "Cumulative Passing", chart_legend_retained: "Cumulative Retained", chart_legend_retained_hist: "Percent Retained", mean_label: "Mean", std_dev_label: "Std Dev",
                    analysis_err_no_fines: "Cannot determine fines percentage (no 75µm sieve data). Classification not possible.", analysis_err_no_coeffs: "Not enough data for soil classification. D10, D30, and D60 values are required.",
                    analysis_err_no_split: "Cannot determine sand/gravel split (no 4.75mm/4750µm sieve data). Classification not possible.",
                    analysis_title_uscs: "USCS Soil Classification: ",
                    analysis_fine_grained: "The material is fine-grained (over 50% passing 75µm sieve). Atterberg limits are needed for full classification.",
                    analysis_coarse_grained: "The material is coarse-grained ({value}% retained on 75µm sieve). ",
                    analysis_base_gravel: "The coarse fraction is primarily Gravel ({value}%). ",
                    analysis_base_sand: "The coarse fraction is primarily Sand ({value}%). ",
                    analysis_fines_lt_5: "Fines < 5%. ",
                    analysis_fines_gt_12: "Fines > 12%. ",
                    analysis_fines_borderline: "Borderline case (5-12% fines). ",
                    analysis_gw: "Classification: GW (Well-graded gravel).",
                    analysis_gp: "Classification: GP (Poorly-graded gravel).",
                    analysis_plasticity_gm_gc: "Further plasticity tests needed to classify as GM (silty gravel) or GC (clayey gravel).",
                    analysis_dual_symbol_gravel: "Requires dual symbol (e.g., GW-GM, GP-GC).",
                    analysis_sw: "Classification: SW (Well-graded sand).",
                    analysis_sp: "Classification: SP (Poorly-graded sand).",
                    analysis_plasticity_sm_sc: "Further plasticity tests needed to classify as SM (silty sand) or SC (clayey sand).",
                    analysis_dual_symbol_sand: "Requires dual symbol (e.g., SW-SM, SP-SC).",
                    analysis_cu_value: "Cu = {value}. ",
                    analysis_cc_value: "Cc = {value}. ",
                    analysis_title_concrete: "\nConcrete Aggregate Analysis: ",
                    analysis_fm_value: "Fineness Modulus (FM) = {value}. ",
                    analysis_fm_good: "This FM is within the typical range (2.3-3.1) for fine aggregate (ASTM C33).",
                    analysis_fm_fine: "This indicates the sand is finer than is typical for concrete aggregate.",
                    analysis_fm_coarse: "This indicates the sand is coarser than is typical for concrete aggregate.",
                    analysis_fm_na: "Fineness Modulus could not be calculated. Ensure standard sieves are included.",
                    analysis_title_heap_leach: "\nHeap Leach (Oxidized Copper) Analysis: ",
                    analysis_heap_leach_fines_ok: "Fines content ({value}%) is suitable for maintaining heap permeability. ",
                    analysis_heap_leach_fines_high: "Fines content ({value}%) is high, which may risk reducing heap permeability and recovery. ",
                    analysis_heap_leach_d80: "The D80 crush size is {value} mm. ",
                    analysis_heap_leach_d80_coarse: "This is a coarse crush, which may lead to lower copper recovery. ",
                    analysis_heap_leach_d80_fine: "This is a fine crush, which may increase recovery but could risk heap stability and permeability. "
                },
                fa: {
                    title: "آنالیز دانه‌بندی مصالح", header_title: "آنالیز دانه‌بندی", lang_button: "English", export_pdf: "خروجی PDF", export_excel: "خروجی Excel",
                    material_selection_title: "۱. انتخاب نوع مصالح", crushed_rock: "سنگ شکن", concrete_aggregates: "بتن", soil_clay: "رس",
                    image_analysis_title: "آنالیز تصویری سنگ شکن",
                    guide_title: "راهنمای تهیه تصویر",
                    guide_item1: "تصویر را از فاصله حدودا ۱ متری و به صورت کاملا عمود بر سطح بگیرید.",
                    guide_item2: "یک شیء مرجع با اندازه مشخص (مانند سکه یا درب بطری) در کنار مصالح قرار دهید.",
                    guide_item3: "مصالح را روی یک سطح صاف با رنگ متضاد (مانند پارچه یا ژئوممبران تیره) پخش کنید.",
                    guide_item4: "برای بهترین دقت، از حالت «دستی» استفاده کرده و یک خط در امتداد قطر شیء مرجع رسم کنید.",
                    image_upload_label: "۱. بارگذاری تصویر مصالح",
                    camera_button: "استفاده از دوربین",
                    reference_diameter_label: "۲. قطر واقعی شیء مرجع (mm)",
                    detection_mode_label: "حالت تشخیص شیء مرجع:",
                    detection_mode_auto: "خودکار (تشخیص دایره)",
                    detection_mode_manual: "دستی (رسم خط)",
                    manual_prompt: "روی تصویر کلیک کرده و بکشید تا یک خط در امتداد قطر شیء مرجع رسم شود.",
                    process_image_button: "۳. پردازش تصویر و محاسبه دانه‌بندی",
                    camera_modal_title: "گرفتن عکس",
                    camera_modal_cancel: "انصراف",
                    camera_modal_capture: "عکس گرفتن",
                    sieve_inputs_title: "۲. ورود اطلاعات سرندها", sieve_name: "نام سرند", sieve_size: "اندازه سرند (µm)", retained_weight: "وزن باقی‌مانده (گرم)",
                    actions: "عملیات", add_sieve: "افزودن سرند", delete_button: "حذف", calculate_button: "محاسبه", results_title: "۳. نتایج آنالیز", cu: "ضریب یکنواختی (Cu):",
                    cc: "ضریب انحنا (Cc):", mean: "میانگین وزنی (μm):", std_dev: "انحراف معیار:", analysis_title: "تحلیل متنی", charts_title: "۴. نمودارها",
                    retained_75mm: "درصد بزرگتر از ۷۵ میلی متر:", retained_45mm: "درصد بزرگتر از ۴۵ میلی متر:",
                    alert_no_weight: "وزن کل نمی‌تواند صفر باشد. لطفاً وزن‌های باقی‌مانده را وارد کنید.", alert_no_calculation: "لطفاً ابتدا یک محاسبه انجام دهید.", generating: "در حال تولید...",
                    pdf_modal_title: "اطلاعات گزارش PDF", pdf_modal_report_title: "عنوان گزارش", pdf_modal_report_desc: "توضیحات", pdf_modal_report_date: "تاریخ",
                    pdf_modal_cancel: "انصراف", pdf_modal_confirm: "تولید گزارش", pan: "سینی", raw_data_title: "داده‌های خام",
                    chart_title_passing: "منحنی تجمعی عبوری", chart_title_retained: "منحنی تجمعی باقی‌مانده", chart_title_histogram: "هیستوگرام (درصد باقی‌مانده)",
                    chart_xaxis_label: "اندازه سرند (µm) - مقیاس لگاریتمی", chart_yaxis_passing: "درصد عبوری (%)", chart_yaxis_retained: "درصد باقی‌مانده (%)", chart_yaxis_retained_hist: "درصد باقی‌مانده (%)",
                    chart_legend_passing: "عبوری تجمعی", chart_legend_retained: "باقی‌مانده تجمعی", chart_legend_retained_hist: "درصد باقی‌مانده", mean_label: "میانگین", std_dev_label: "انحراف معیار",
                    analysis_err_no_fines: "امکان تعیین درصد ریزدانه (بدون داده سرند ۷۵µm) وجود ندارد. طبقه‌بندی ممکن نیست.", analysis_err_no_coeffs: "داده‌های کافی برای طبقه‌بندی خاک وجود ندارد. مقادیر D10، D30 و D60 مورد نیاز است.",
                    analysis_err_no_split: "امکان تفکیک شن و ماسه (بدون داده سرند ۴.۷۵mm/۴۷۵۰µm) وجود ندارد. طبقه‌بندی ممکن نیست.",
                    analysis_title_uscs: "طبقه‌بندی خاک (USCS): ",
                    analysis_fine_grained: "ماده ریزدانه است (بیش از ۵۰٪ عبوری از سرند ۷۵µm). برای طبقه‌بندی کامل به حدود اتربرگ نیاز است.",
                    analysis_coarse_grained: "ماده درشت‌دانه است ({value}٪ مانده روی سرند ۷۵µm). ",
                    analysis_base_gravel: "بخش درشت‌دانه عمدتا شن ({value}٪) است. ",
                    analysis_base_sand: "بخش درشت‌دانه عمدتا ماسه ({value}٪) است. ",
                    analysis_fines_lt_5: "ریزدانه کمتر از ۵٪. ",
                    analysis_fines_gt_12: "ریزدانه بیشتر از ۱۲٪. ",
                    analysis_fines_borderline: "حالت مرزی (ریزدانه بین ۵ تا ۱۲٪). ",
                    analysis_gw: "طبقه‌بندی: GW (شن خوب دانه‌بندی شده).",
                    analysis_gp: "طبقه‌بندی: GP (شن بد دانه‌بندی شده).",
                    analysis_plasticity_gm_gc: "برای طبقه‌بندی به عنوان GM (شن لای‌دار) یا GC (شن رس‌دار) به آزمایش‌های خمیری بیشتری نیاز است.",
                    analysis_dual_symbol_gravel: "نیازمند نماد دوگانه است (مانند GW-GM، GP-GC).",
                    analysis_sw: "طبقه‌بندی: SW (ماسه خوب دانه‌بندی شده).",
                    analysis_sp: "طبقه‌بندی: SP (ماسه بد دانه‌بندی شده).",
                    analysis_plasticity_sm_sc: "برای طبقه‌بندی به عنوان SM (ماسه لای‌دار) یا SC (ماسه رس‌دار) به آزمایش‌های خمیری بیشتری نیاز است.",
                    analysis_dual_symbol_sand: "نیازمند نماد دوگانه است (مانند SW-SM، SP-SC).",
                    analysis_cu_value: "Cu = {value}. ",
                    analysis_cc_value: "Cc = {value}. ",
                    analysis_title_concrete: "\nتحلیل سنگدانه بتن: ",
                    analysis_fm_value: "مدول نرمی (FM) = {value}. ",
                    analysis_fm_good: "این مدول نرمی در محدوده استاندارد (۲.۳-۳.۱) برای سنگدانه ریز (ASTM C33) قرار دارد.",
                    analysis_fm_fine: "این نشان می‌دهد که ماسه ریزتر از حد معمول برای سنگدانه بتن است.",
                    analysis_fm_coarse: "این نشان می‌دهد که ماسه درشت‌تر از حد معمول برای سنگدانه بتن است.",
                    analysis_fm_na: "مدول نرمی قابل محاسبه نیست. از وجود سرندهای استاندارد اطمینان حاصل کنید.",
                    analysis_title_heap_leach: "\nتحلیل هیپ لیچینگ (مس اکسیدی): ",
                    analysis_heap_leach_fines_ok: "میزان ریزدانه ({value}٪) برای حفظ نفوذپذیری توده مناسب است. ",
                    analysis_heap_leach_fines_high: "میزان ریزدانه ({value}٪) بالا است که می‌تواند خطر کاهش نفوذپذیری و بازیابی را به همراه داشته باشد. ",
                    analysis_heap_leach_d80: "اندازه خردایش D80 برابر با {value} میلی‌متر است. ",
                    analysis_heap_leach_d80_coarse: "این خردایش درشت است که ممکن است منجر به بازیابی کمتر مس شود. ",
                    analysis_heap_leach_d80_fine: "این خردایش ریز است که ممکن است بازیابی را افزایش دهد اما می‌تواند پایداری و نفوذپذیری توده را به خطر اندازد. "
                }
            };

            let currentLang = 'fa';

            function setLanguage(lang) {
                currentLang = lang;
                document.documentElement.lang = lang;
                document.documentElement.dir = lang === 'fa' ? 'rtl' : 'ltr';
                document.querySelectorAll('[data-lang-key]').forEach(el => {
                    const key = el.getAttribute('data-lang-key');
                    if (translations[lang][key]) el.textContent = translations[lang][key];
                });
                if (lastCalculationData) {
                    const newAnalysisText = lastCalculationData.analysisKeys.map(key => translations[lang][key] || key).join(' ');
                    document.getElementById('text-analysis-output').textContent = newAnalysisText;
                    updateCharts();
                }
            }

            function toggleLanguage() {
                setLanguage(currentLang === 'fa' ? 'en' : 'fa');
            }
            setLanguage(currentLang);
        });
    </script>
</body>
</html>
